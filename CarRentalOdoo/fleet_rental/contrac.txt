from datetime import datetime, date, timedelta
from odoo import api, fields, models, _
from odoo.exceptions import UserError, ValidationError


class CarRentalContract(models.Model):
    _name = 'car.rental.contract'
    _inherit = 'mail.thread'
    _description = 'Gestion de la location de flotte'

    image = fields.Binary(related='vehicle_id.image_128',
                          string="Image du véhicule")
    reserved_fleet_id = fields.Many2one('rental.fleet.reserved',
                                        invisible=True,
                                        copy=False)
    name = fields.Char(string="Nom",
                       default="Contrat brouillon",
                       readonly=True,
                       copy=False)
    customer_id = fields.Many2one('res.partner',
                                  required=True,
                                  string='Client',
                                  help="Client")
    vehicle_id = fields.Many2one('fleet.vehicle',
                                 string="Véhicule",
                                 required=True,
                                 help="Véhicule")
    car_brand = fields.Many2one('fleet.vehicle.model.brand',
                                string="Marque de flotte",
                                size=50,
                                related='vehicle_id.model_id.brand_id',
                                store=True,
                                readonly=True)
    car_color = fields.Char(string="Couleur de flotte",
                            size=50,
                            related='vehicle_id.color',
                            store=True,
                            copy=False,
                            default='#FFFFFF',
                            readonly=True)
    cost = fields.Float(string="Coût de location",
                        help="Ce champ est utilisé pour déterminer le coût de la location",
                        required=True)
    rent_start_date = fields.Date(string="Date de début de location",
                                  required=True,
                                  default=str(date.today()),
                                  help="Date de début du contrat",
                                  track_visibility='onchange')
    start_time = fields.Char(string="Commence à",
                             help="Entrez l'heure de début du contrat")
    end_time = fields.Char(string="Se termine à",
                           help="Entrez l'heure de fin du contrat")
    rent_by_hour = fields.Boolean(string="Location à l'heure",
                                  help="Activer pour commencer le contrat sur une base horaire")
    rent_end_date = fields.Date(string="Date de fin de location",
                                required=True,
                                help="Date de fin du contrat",
                                track_visibility='onchange')
    state = fields.Selection(
        [('draft', 'Brouillon'), ('reserved', 'Réservé'), ('running', 'En cours'),
         ('cancel', 'Annulé'),
         ('checking', 'En vérification'), ('invoice', 'Facture'), ('done', 'Terminé')],
        string="État", default="draft",
        copy=False, track_visibility='onchange')
    notes = fields.Text(string="Détails & Notes")
    cost_generated = fields.Float(string='Coût récurrent',
                                  help="Coûts payés à intervalles réguliers, en fonction de la fréquence des coûts")
    cost_frequency = fields.Selection(
        [('no', 'Non'), ('daily', 'Quotidien'), ('weekly', 'Hebdomadaire'),
         ('monthly', 'Mensuel'),
         ('yearly', 'Annuel')], string="Fréquence des coûts récurrents",
        help='Fréquence du coût récurrent', required=True)
    journal_type = fields.Many2one('account.journal', 'Journal',
                                   default=lambda self: self.env[
                                       'account.journal'].search(
                                       [('id', '=', 1)]))
    account_type = fields.Many2one('account.account', 'Compte',
                                   default=lambda self: self.env[
                                       'account.account'].search(
                                       [('id', '=', 17)]))
    recurring_line = fields.One2many('fleet.rental.line', 'rental_number',
                                     readonly=True, help="Factures récurrentes",
                                     copy=False)
    first_payment = fields.Float(string='Premier paiement',
                                 help="Montant des frais de transaction/bureau/contrat, doit être payé par le client en plus des paiements récurrents",
                                 track_visibility='onchange',
                                 required=True)
    first_payment_inv = fields.Many2one('account.move', copy=False)
    first_invoice_created = fields.Boolean(string="Première facture créée",
                                           invisible=True, copy=False)
    attachment_ids = fields.Many2many('ir.attachment',
                                      'car_rent_checklist_ir_attachments_rel',
                                      'rental_id', 'attachment_id',
                                      string="Pièces jointes",
                                      help="Images du véhicule avant le contrat / toutes pièces jointes")
    checklist_line = fields.One2many('car.rental.checklist',
                                     'checklist_number', string="Liste de vérification",
                                     help="Installations / accessoires, à vérifier lors de la clôture du contrat.")
    total = fields.Float(string="Total (Accessoires/Outils)", readonly=True,
                         copy=False)
    tools_missing_cost = fields.Float(string="Coût des outils manquants", readonly=True,
                                      copy=False,
                                      help='Ceci est le montant total des outils/accessoires manquants')
    damage_cost = fields.Float(string="Coût des dommages / Montant du solde",
                               copy=False)
    damage_cost_sub = fields.Float(string="Coût des dommages / Montant du solde",
                                   readonly=True,
                                   copy=False)
    total_cost = fields.Float(string="Total", readonly=True, copy=False)
    invoice_count = fields.Integer(compute='_invoice_count',
                                   string='# Facture', copy=False)
    check_verify = fields.Boolean(compute='check_action_verify', copy=False)
    sales_person = fields.Many2one('res.users', string='Vendeur',
                                   default=lambda self: self.env.uid,
                                   track_visibility='always')
    read_only = fields.Boolean(string="Lecture seule", help="Pour rendre le champ en lecture seule")
    company_id = fields.Many2one('res.company', string='Entreprise',
                                 default=lambda self: self.env.company,
                                 help="Entreprise propriétaire de cet enregistrement")
    
    # Add these new fields based on the provided images
    last_odometer = fields.Float(string="Dernier compteur kilométrique",
                             help="Dernier compteur kilométrique",
                             related='vehicle_id.dernier_releve_kilometrique',
                             readonly=True)
    new_odometer = fields.Float(string="Nouveau compteur kilométrique",
                            help="Nouveau compteur kilométrique",
                            compute='_compute_new_odometer_visibility',
                            store=True)
    new_odometer_visible = fields.Boolean(compute='_compute_new_odometer_visibility', store=True)

    fuel_level = fields.Selection([('1/4', '1/4'), ('1/2', '1/2'), ('3/4', '3/4'), ('Plein', 'Plein')],
                                  string="Niveau Carburant", help="Niveau de carburant")
    change_vehicle = fields.Boolean(string="Changement Véhicule", help="Indique si le véhicule est changé")
    new_vehicle_id = fields.Many2one('fleet.vehicle', string="Nouveau véhicule", help="Nouveau véhicule")
    deposit = fields.Float(string="Acompte")
    currency_id = fields.Many2one('res.currency', string="Devise")
    payment_mode = fields.Selection([('Espèce', 'Espèce'), ('Carte', 'Carte'), ('Virement', 'Virement')],
                                    string="Mode de paiement")
    second_driver = fields.Many2one('res.partner', string="2ème Conducteur", help="Deuxième conducteur")
    total_days = fields.Integer(string="Total Jours", compute='_compute_total_days')
    total_cost = fields.Float(string="Total Location", compute='_compute_total_cost')

    def write(self, vals):
        res = super(CarRentalContract, self).write(vals)
        for record in self:
            if record.state == 'done':
                record.vehicle_id.dernier_releve_kilometrique = record.new_odometer
        return res


    @api.depends('state')
    def _compute_new_odometer_visibility(self):
        for record in self:
            record.new_odometer_visible = record.state == 'done'


    @api.depends('rent_start_date', 'rent_end_date')
    def _compute_total_days(self):
        for record in self:
            if record.rent_start_date and record.rent_end_date:
                delta = record.rent_end_date - record.rent_start_date
                record.total_days = delta.days + 1  # inclusive of both start and end date
            else:
                record.total_days = 0

    @api.depends('total_days', 'vehicle_id.tarif')
    def _compute_total_cost(self):
        for record in self:
            if record.vehicle_id and record.total_days:
                record.total_cost = record.total_days * record.vehicle_id.tarif
            else:
                record.total_cost = 0.0


    # Keep existing methods as they are

   
    def action_cancel(self):
        """
           Annuler le contrat de location.
           Mettre à jour l'état sur "annulé".
       """
        self.state = "cancel"

    def action_done(self):
        """
           Terminer le contrat de location.
           Mettre à jour l'état sur "Terminé".
       """
        self.state = "done"

    def action_run(self):
        """
            Définir l'état de l'objet sur 'en cours'.
        """
        self.state = 'running'


                    #Alert functions #
    @api.constrains('rent_start_date', 'rent_end_date', 'vehicle_id')
    def _check_vidange_dates(self):
        for record in self:
            if record.vehicle_id and record.vehicle_id.date_vidange:
                alert_date = record.vehicle_id.date_vidange - timedelta(days=record.vehicle_id.nbr_kilometres_alerte)
                if record.rent_start_date <= alert_date <= record.rent_end_date:
                    raise ValidationError(
                        "Attention: La date de vidange du véhicule tombe dans la période de location et le seuil d'alerte."
                    )
                if record.rent_start_date <= record.vehicle_id.date_vidange <= record.rent_end_date:
                    raise ValidationError(
                        "Attention: La date de vidange du véhicule tombe dans la période de location."
                    )          

    @api.constrains('rent_start_date', 'rent_end_date', 'vehicle_id')
    def _check_leasing_dates(self):
        for record in self:
            if record.vehicle_id and record.vehicle_id.date_echeance_leasing:
                alert_date = record.vehicle_id.date_echeance_leasing - timedelta(days=record.vehicle_id.nbr_jours_alerte_leasing)
                if record.rent_start_date <= alert_date <= record.rent_end_date:
                    raise ValidationError(
                        "Attention: La date d'échéance du leasing du véhicule tombe dans la période de location et le seuil d'alerte."
                    )
                if record.rent_start_date <= record.vehicle_id.date_echeance_leasing <= record.rent_end_date:
                    raise ValidationError(
                        "Attention: La date d'échéance du leasing du véhicule tombe dans la période de location."
                    )
                
    @api.constrains('rent_start_date', 'rent_end_date', 'vehicle_id')
    def _check_visite_technique_dates(self):
        for record in self:
            if record.vehicle_id and record.vehicle_id.date_echeance_visite:
                alert_date = record.vehicle_id.date_echeance_visite - timedelta(days=record.vehicle_id.nbr_jour_alerte_visite)
                if record.rent_start_date <= alert_date <= record.rent_end_date:
                    raise ValidationError(
                        "Attention: La date de visite technique du véhicule tombe dans la période de location et le seuil d'alerte."
                    )
                if record.rent_start_date <= record.vehicle_id.date_echeance_visite <= record.rent_end_date:
                    raise ValidationError(
                        "Attention: La date de visite technique du véhicule tombe dans la période de location."
                    )
            
    @api.constrains('rent_start_date', 'rent_end_date', 'vehicle_id')
    def _check_vignette_dates(self):
        for record in self:
            if record.vehicle_id and record.vehicle_id.date_echeance_vignette:
                alert_date = record.vehicle_id.date_echeance_vignette - timedelta(days=record.vehicle_id.nbr_jour_alerte_vignette)
                if record.rent_start_date <= alert_date <= record.rent_end_date:
                    raise ValidationError(
                        "Attention: La date d'échéance de la vignette du véhicule tombe dans la période de location et le seuil d'alerte."
                    )
                if record.rent_start_date <= record.vehicle_id.date_echeance_vignette <= record.rent_end_date:
                    raise ValidationError(
                        "Attention: La date d'échéance de la vignette du véhicule tombe dans la période de location."
                    )

    @api.depends('checklist_line.checklist_active')
    def check_action_verify(self):
        """
            Mettre à jour le champ 'check_verify' en fonction de la valeur de 'checklist_active' dans 'checklist_line'.
        """
        flag = 0
        for each in self:
            for i in each.checklist_line:
                if i.checklist_active:
                    continue
                else:
                    flag = 1
            if flag == 1:
                each.check_verify = False
            else:
                each.check_verify = True

    @api.constrains('rent_start_date', 'rent_end_date')
    def validate_dates(self):
        """
            Vérifier la validité des champs 'rent_start_date' et 'rent_end_date'.
            Lever un avertissement si 'rent_end_date' est antérieur à 'rent_start_date'.
        """
        if self.rent_end_date < self.rent_start_date:
            raise UserError("Veuillez sélectionner une date de fin valide.")

    def set_to_done(self):
        """Set the state to 'done' if the contract is fully paid."""
        for record in self:
            invoice_ids = self.env['account.move'].search(
                [('fleet_rent_id', '=', self.id)])
            if any(invoice.payment_state != 'paid' for invoice in invoice_ids):
                raise UserError("Le contrat ne peut être terminé que lorsque toutes les factures sont payées.")
            record.state = 'done'

    def _invoice_count(self):
        """
            Calculer le nombre de factures liées à l'objet actuel.
            Mettre à jour le champ 'invoice_count' en conséquence.
        """
        self.invoice_count = self.env['account.move'].search_count(
            [('fleet_rent_id', '=', self.id)])

    @api.constrains('state')
    def state_changer(self):
        """
            Gérer les transitions d'état et mettre à jour le 'state_id' du véhicule associé en fonction de la valeur du champ 'state'.
        """
        if self.state == "running":
            state_id = self.env.ref('fleet_rental.vehicle_state_rent').id
            self.vehicle_id.write({'state_id': state_id})
        elif self.state == "cancel":
            state_id = self.env.ref('fleet_rental.vehicle_state_active').id
            self.vehicle_id.write({'state_id': state_id})
        elif self.state == "invoice":
            self.rent_end_date = fields.Date.today()
            state_id = self.env.ref('fleet_rental.vehicle_state_active').id
            self.vehicle_id.write({'state_id': state_id})

    @api.constrains('checklist_line', 'damage_cost')
    def total_updater(self):
        """
           Mettre à jour divers champs liés aux totaux en fonction des valeurs dans 'checklist_line', 'damage_cost' et d'autres champs pertinents.
       """
        total = 0.0
        tools_missing_cost = 0.0
        for records in self.checklist_line:
            total += records.price
            if not records.checklist_active:
                tools_missing_cost += records.price
        self.total = total
        self.tools_missing_cost = tools_missing_cost
        self.damage_cost_sub = self.damage_cost
        self.total_cost = tools_missing_cost + self.damage_cost

    def fleet_scheduler1(self, rent_date):
        """
            Effectuer des actions liées à la planification de la flotte, y compris la création de factures, la gestion des données récurrentes et l'envoi de notifications par e-mail.
        """
        inv_obj = self.env['account.move']
        recurring_obj = self.env['fleet.rental.line']
        supplier = self.customer_id
        product_id = self.env['product.product'].browse(
            self.env.ref('fleet_rental.fleet_service_product').id)
        if product_id.property_account_income_id.id:
            income_account = product_id.property_account_income_id
        elif product_id.categ_id.property_account_income_categ_id.id:
            income_account = product_id.categ_id.property_account_income_categ_id
        else:
            raise UserError(
                _('Veuillez définir le compte de revenu pour ce produit : "%s" (id:%d).') % (
                    product_id.name,
                    product_id.id))
        inv_data = {
            'ref': supplier.name,
            'partner_id': supplier.id,
            'journal_id': self.journal_type.id,
            'invoice_origin': self.name,
            'fleet_rent_id': self.id,
            'invoice_payment_term_id': None,
            'invoice_date_due': self.rent_end_date,
            'move_type': 'out_invoice',
            'invoice_line_ids': [(0, 0, {
                'account_id': income_account.id,
                'price_unit': self.cost_generated,
                'quantity': 1,
                'product_id': product_id.id,
            })]
        }
        inv_id = inv_obj.create(inv_data)

        recurring_data = {
            'name': self.vehicle_id.name,
            'date_today': rent_date,
            'account_info': income_account.name,
            'rental_number': self.id,
            'recurring_amount': self.cost_generated,
            'invoice_number': inv_id.id,
            'invoice_ref': inv_id.id,
        }
        recurring_obj.create(recurring_data)
        mail_content = _(
            '<h3>Rappel de paiement récurrent!</h3><br/>Bonjour %s, <br/> Ceci est pour vous rappeler que le paiement récurrent pour le contrat de location doit être effectué.'
            'Veuillez effectuer le paiement dans les plus brefs délais.'
            '<br/><br/>'
            'Veuillez trouver les détails ci-dessous:<br/><br/>'
            '<table><tr><td>Référence du contrat<td/><td> %s<td/><tr/>'
            '<tr/><tr><td>Montant <td/><td> %s<td/><tr/>'
            '<tr/><tr><td>Date d\'échéance <td/><td> %s<td/><tr/>'
            '<tr/><tr><td>Personne responsable <td/><td> %s, %s<td/><tr/><table/>') % \
                       (self.customer_id.name, self.name, inv_id.amount_total,
                        inv_id.invoice_date_due,
                        inv_id.user_id.name,
                        inv_id.user_id.phone)
        main_content = {
            'subject': "Rappel de paiement récurrent!",
            'author_id': self.env.user.partner_id.id,
            'body_html': mail_content,
            'email_to': self.customer_id.email,
        }
        self.env['mail.mail'].create(main_content).send()

    @api.model
    def fleet_scheduler(self):
        """
            Effectuer des opérations de planification de la flotte, y compris la création de factures, la gestion des données récurrentes et l'envoi de notifications par e-mail.
        """
        inv_obj = self.env['account.move']
        recurring_obj = self.env['fleet.rental.line']
        today = date.today()
        for records in self.search([]):
            start_date = datetime.strptime(str(records.rent_start_date),
                                           '%Y-%m-%d').date()
            end_date = datetime.strptime(str(records.rent_end_date),
                                         '%Y-%m-%d').date()
            if end_date >= date.today():
                temp = 0
                if records.cost_frequency == 'daily':
                    temp = 1
                elif records.cost_frequency == 'weekly':
                    week_days = (date.today() - start_date).days
                    if week_days % 7 == 0 and week_days != 0:
                        temp = 1
                elif records.cost_frequency == 'monthly':
                    if start_date.day == date.today().day and start_date != date.today():
                        temp = 1
                elif records.cost_frequency == 'yearly':
                    if start_date.day == date.today().day and start_date.month == date.today().month and \
                            start_date != date.today():
                        temp = 1
                if temp == 1 and records.cost_frequency != "no" and records.state == "running":
                    supplier = records.customer_id
                    product_id = self.env['product.product'].browse(
                        self.env.ref('fleet_rental.fleet_service_product').id)
                    if product_id.property_account_income_id.id:
                        income_account = product_id.property_account_income_id
                    elif product_id.categ_id.property_account_income_categ_id.id:
                        income_account = product_id.categ_id.property_account_income_categ_id
                    else:
                        raise UserError(
                            _('Veuillez définir le compte de revenu pour ce produit : "%s" (id:%d).') % (
                                product_id.name,
                                product_id.id))
                    inv_data = {
                        'ref': supplier.name,
                        'partner_id': supplier.id,
                        'currency_id': records.account_type.company_id.currency_id.id,
                        'journal_id': records.journal_type.id,
                        'invoice_origin': records.name,
                        'fleet_rent_id': records.id,
                        'invoice_date': today,
                        'company_id': records.account_type.company_id.id,
                        'invoice_payment_term_id': None,
                        'invoice_date_due': records.rent_end_date,
                        'move_type': 'out_invoice',
                        'invoice_line_ids': [(0, 0, {
                            'account_id': income_account.id,
                            'price_unit': records.cost_generated,
                            'quantity': 1,
                            'product_id': product_id.id,
                        })]
                    }
                    inv_id = inv_obj.create(inv_data)
                    recurring_data = {
                        'name': records.vehicle_id.name,
                        'date_today': today,
                        'account_info': income_account.name,
                        'rental_number': records.id,
                        'recurring_amount': records.cost_generated,
                        'invoice_number': inv_id.id,
                        'invoice_ref': inv_id.id,
                    }
                    recurring_obj.create(recurring_data)

                    mail_content = _(
                        '<h3>Rappel de paiement récurrent!</h3><br/>Bonjour %s, <br/> Ceci est pour vous rappeler que le paiement récurrent pour le contrat de location doit être effectué.'
                        'Veuillez effectuer le paiement dans les plus brefs délais.'
                        '<br/><br/>'
                        'Veuillez trouver les détails ci-dessous:<br/><br/>'
                        '<table><tr><td>Référence du contrat<td/><td> %s<td/><tr/>'
                        '<tr/><tr><td>Montant <td/><td> %s<td/><tr/>'
                        '<tr/><tr><td>Date d\'échéance <td/><td> %s<td/><tr/>'
                        '<tr/><tr><td>Personne responsable <td/><td> %s, %s<td/><tr/><table/>') % \
                                   (self.customer_id.name, self.name,
                                    inv_id.amount_total,
                                    inv_id.invoice_date_due,
                                    inv_id.user_id.name,
                                    inv_id.user_id.mobile)
                    main_content = {
                        'subject': "Rappel de paiement récurrent!",
                        'author_id': self.env.user.partner_id.id,
                        'body_html': mail_content,
                        'email_to': self.customer_id.email,
                    }
                    self.env['mail.mail'].create(main_content).send()
            else:
                if self.state == 'running':
                    records.state = "checking"

    def action_verify(self):
        """
            Vérifie le coût des dommages ou le coût des outils manquants
        """
        self.state = "invoice"
        self.reserved_fleet_id.unlink()
        self.rent_end_date = fields.Date.today()
        self.vehicle_id.rental_check_availability = True
        product_id = self.env['product.product'].browse(
            self.env.ref('fleet_rental.fleet_service_product').id)
        if product_id.property_account_income_id.id:
            income_account = product_id.property_account_income_id
        elif product_id.categ_id.property_account_income_categ_id.id:
            income_account = product_id.categ_id.property_account_income_categ_id
        else:
            raise UserError(
                _('Veuillez définir le compte de revenu pour ce produit : "%s" (id:%d).') % (
                    product_id.name,
                    product_id.id))
        if self.total_cost != 0:
            supplier = self.customer_id
            inv_data = {
                'ref': supplier.name,
                'move_type': 'out_invoice',
                'partner_id': supplier.id,
                'currency_id': self.account_type.company_id.currency_id.id,
                'journal_id': self.journal_type.id,
                'invoice_origin': self.name,
                'fleet_rent_id': self.id,
                'company_id': self.account_type.company_id.id,
                'invoice_date_due': self.rent_end_date,
                'invoice_line_ids': [(0, 0, {
                    'name': "Coût des dommages / Outils manquants",
                    'account_id': income_account.id,
                    'price_unit': self.total_cost,
                    'quantity': 1,
                    'product_id': product_id.id,
                })]
            }
            inv_id = self.env['account.move'].create(inv_data)
            list_view_id = self.env.ref('account.view_move_form', False)
            form_view_id = self.env.ref('account.view_move_tree', False)
            result = {
                'name': 'Factures de location de flotte',
                'view_mode': 'form',
                'res_model': 'account.move',
                'type': 'ir.actions.act_window',
                'views': [(list_view_id.id, 'tree'),
                          (form_view_id.id, 'form')],
            }
            if len(inv_id) > 1:
                result['domain'] = "[('id','in',%s)]" % inv_id.ids
            else:
                result = {'type': 'ir.actions.act_window_close'}
            return result

    def action_confirm(self):
        """
           Confirmer le contrat de location, vérifier la disponibilité du véhicule, mettre à jour l'état à "réservé", générer un code de séquence et envoyer un e-mail de confirmation.
        """
        self.vehicle_id.rental_check_availability = False
        check_availability = 0
        for each in self.vehicle_id.rental_reserved_time:
            if each.date_from <= self.rent_start_date <= each.date_to:
                check_availability = 1
            elif self.rent_start_date < each.date_from:
                if each.date_from <= self.rent_end_date <= each.date_to:
                    check_availability = 1
                elif self.rent_end_date > each.date_to:
                    check_availability = 1
                else:
                    check_availability = 0
            else:
                check_availability = 0
        if check_availability == 0:
            reserved_id = self.vehicle_id.rental_reserved_time.create(
                {'customer_id': self.customer_id.id,
                 'date_from': self.rent_start_date,
                 'date_to': self.rent_end_date,
                 'reserved_obj_id': self.vehicle_id.id
                 })
            self.write({'reserved_fleet_id': reserved_id.id})
        else:
            raise UserError(
                'Désolé, ce véhicule est déjà réservé par un autre client')
        self.state = "reserved"
        sequence_code = 'car.rental.sequence'
        order_date = self.create_date
        order_date = str(order_date)[0:10]
        self.name = self.env['ir.sequence'] \
            .with_context(ir_sequence_date=order_date).next_by_code(
            sequence_code)
        mail_content = _(
            '<h3>Commande confirmée!</h3><br/>Bonjour %s, <br/> Ceci est pour vous informer que votre contrat de location a été confirmé. <br/><br/>'
            'Veuillez trouver les détails ci-dessous:<br/><br/>'
            '<table><tr><td>Numéro de référence<td/><td> %s<td/><tr/>'
            '<tr><td>Période <td/><td> %s à %s <td/><tr/><tr><td>Véhicule <td/><td> %s<td/><tr/>'
            '<tr><td>Personne de contact<td/><td> %s , %s<td/><tr/><table/>') % \
                       (self.customer_id.name, self.name, self.rent_start_date,
                        self.rent_end_date,
                        self.vehicle_id.name, self.sales_person.name,
                        self.sales_person.phone)
        main_content = {
            'subject': _('Confirmé: %s - %s') %
                       (self.name, self.vehicle_id.name),
            'author_id': self.env.user.partner_id.id,
            'body_html': mail_content,
            'email_to': self.customer_id.email,
        }
        self.env['mail.mail'].create(main_content).send()

    def action_cancel(self):
        """
           Annuler le contrat de location.
           Mettre à jour l'état sur "annulé" et supprimer l'ID de flotte réservée associé s'il existe.
       """
        self.state = "cancel"
        self.vehicle_id.rental_check_availability = True
        if self.reserved_fleet_id:
            self.reserved_fleet_id.unlink()

    def force_checking(self):
        """
            Forcer la vérification de l'état de paiement des factures associées.
            Si toutes les factures sont marquées comme payées, mettre à jour l'état sur "en vérification".
            Sinon, lever une UserError indiquant que certaines factures sont en attente.
        """
        invoice_ids = self.env['account.move'].search(
            [('fleet_rent_id', '=', self.id)])
        if any(each.payment_state != 'paid' for each in invoice_ids):
            raise UserError("Certaines factures sont en attente")
        else:
            self.state = "checking"

    def action_view_invoice(self):
        """
            Afficher les factures associées à l'enregistrement actuel.
            Construire les configurations de vue appropriées en fonction du nombre de factures trouvées.
        """
        inv_obj = self.env['account.move'].search(
            [('fleet_rent_id', '=', self.id)])
        inv_ids = []
        for each in inv_obj:
            inv_ids.append(each.id)
        view_id = self.env.ref('account.view_move_form').id
        if inv_ids:
            if len(inv_ids) <= 1:
                value = {
                    'view_type': 'form',
                    'view_mode': 'form',
                    'res_model': 'account.move',
                    'view_id': view_id,
                    'type': 'ir.actions.act_window',
                    'name': _('Facture'),
                    'res_id': inv_ids and inv_ids[0]
                }
            else:
                value = {
                    'domain': [('fleet_rent_id', '=', self.id)],
                    'view_type': 'form',
                    'view_mode': 'tree,form',
                    'res_model': 'account.move',
                    'view_id': False,
                    'type': 'ir.actions.act_window',
                    'name': _('Facture'),
                }
            return value

    def action_invoice_create(self):
        """
            Créer une facture pour le contrat de location.
            Calculer la durée de la location et itérer sur chaque jour pour créer des factures.
            Créer la première facture de paiement, ajouter les données de ligne de facture pertinentes et envoyer une notification par e-mail pour le paiement reçu.
        """
        for each in self:
            rent_date = self.rent_start_date
            if each.cost_frequency != 'no' and rent_date < date.today():
                rental_days = (date.today() - rent_date).days
                if each.cost_frequency == 'weekly':
                    rental_days = int(rental_days / 7)
                if each.cost_frequency == 'monthly':
                    rental_days = int(rental_days / 30)
                if each.cost_frequency == 'yearly':
                    rental_days = int(rental_days / 365)
                for each1 in range(0, rental_days + 1):
                    if rent_date > datetime.strptime(str(each.rent_end_date),
                                                     "%Y-%m-%d").date():
                        break
                    each.fleet_scheduler1(rent_date)
                    if each.cost_frequency == 'daily':
                        rent_date = rent_date + timedelta(days=1)
                    if each.cost_frequency == 'weekly':
                        rent_date = rent_date + timedelta(days=7)
                    if each.cost_frequency == 'monthly':
                        rent_date = rent_date + timedelta(days=30)
                    if each.cost_frequency == 'yearly':
                        rent_date = rent_date + timedelta(days=365)
        self.first_invoice_created = True
        inv_obj = self.env['account.move']
        supplier = self.customer_id
        inv_data = {
            'ref': supplier.name,
            'move_type': 'out_invoice',
            'partner_id': supplier.id,
            'currency_id': self.account_type.company_id.currency_id.id,
            'journal_id': self.journal_type.id,
            'invoice_origin': self.name,
            'fleet_rent_id': self.id,
            'company_id': self.account_type.company_id.id,
            'invoice_date_due': self.rent_end_date,
            'is_first_invoice': True,
        }
        inv_id = inv_obj.create(inv_data)
        self.first_payment_inv = inv_id.id
        product_id = self.env['product.product'].browse(
            self.env.ref('fleet_rental.fleet_service_product').id)
        if product_id.property_account_income_id.id:
            income_account = product_id.property_account_income_id.id
        elif product_id.categ_id.property_account_income_categ_id.id:
            income_account = product_id.categ_id.property_account_income_categ_id.id
        else:
            raise UserError(
                _('Veuillez définir le compte de revenu pour ce produit : "%s" (id:%d).') % (
                    product_id.name,
                    product_id.id))

        if inv_id:
            list_value = [(0, 0, {
                'name': self.vehicle_id.name,
                'price_unit': self.first_payment,
                'quantity': 1.0,
                'account_id': income_account,
                'product_id': product_id.id,
                'move_id': inv_id.id,
            })]
            inv_id.write({'invoice_line_ids': list_value})
        action = self.env.ref('account.action_move_out_invoice_type')
        result = {
            'name': action.name,
            'type': 'ir.actions.act_window',
            'views': [[False, 'form']],
            'target': 'current',
            'res_id': inv_id.id,
            'res_model': 'account.move',
        }
        return result

    def action_extend_rent(self):
        """
            Définir l'attribut 'read_only' sur True, indiquant que l'action d'extension de location est en cours d'exécution et que les champs correspondants doivent être rendus en lecture seule.

            Cette méthode est généralement utilisée dans le contexte de l'extension d'un contrat de location.
        """
        self.read_only = True

    def action_confirm_extend_rent(self):
        """
            Confirmer l'extension d'un contrat de location et mettre à jour la période réservée pour le véhicule associé.

            Cette méthode définit le champ 'date_to' de la période réservée pour le véhicule sur la valeur spécifiée 'rent_end_date', indiquant la période de location prolongée. Après avoir confirmé l'extension, l'attribut 'read_only' est défini sur False pour permettre d'autres modifications.

            Cette méthode est généralement appelée lorsqu'un utilisateur confirme l'extension d'une location.
        """
        self.vehicle_id.rental_reserved_time.write(
            {
                'date_to': self.rent_end_date,
            })
        self.read_only = False

    @api.constrains('start_time', 'end_time', 'rent_start_date',
                    'rent_end_date')
    def validate_time(self):
        """
            Valider les contraintes de temps pour un contrat de location.

            Cette méthode est utilisée comme contrainte pour s'assurer que les heures de début et de fin spécifiées sont valides, en particulier lors de la location à l'heure. Si la location se fait à l'heure, elle vérifie si l'heure de fin est supérieure à l'heure de début lorsque les dates de début et de fin de location sont identiques.

            :raises ValidationError: Si les contraintes de temps ne sont pas respectées, une erreur de validation est levée avec un message d'erreur pertinent.
        """
        if self.rent_by_hour:
            start_time = datetime.strptime(self.start_time, "%H:%M").time()
            end_time = datetime.strptime(self.end_time, "%H:%M").time()
            if (self.rent_end_date == self.rent_start_date and
                    end_time <= start_time):
                raise ValidationError("Veuillez choisir une heure de fin différente")

    @api.constrains('rent_end_date')
    def validate_on_read_only(self):
        old_date = self.vehicle_id.rental_reserved_time.date_to
        if self.read_only:
            if self.rent_end_date <= old_date:
                raise ValidationError(
                    f"Veuillez choisir une date supérieure à {old_date}")

    def action_discard_extend(self):
        """
            Valider le 'rent_end_date' lorsque le contrat de location est en mode lecture seule.

            Cette contrainte vérifie si le contrat de location est marqué comme lecture seule, indiquant qu'il a été prolongé ou modifié. Si en mode lecture seule, elle compare le 'rent_end_date' avec la valeur existante 'date_to' dans la période réservée du véhicule associé. Elle s'assure que le 'rent_end_date' est supérieur à la date existante pour maintenir la cohérence.

            :raises ValidationError: Si le 'rent_end_date' n'est pas supérieur à la date existante 'date_to', une erreur de validation est levée avec un message d'erreur pertinent.
        """
        self.read_only = False
        self.rent_end_date = self.vehicle_id.rental_reserved_time.date_to









"""""""""""""""""zyeda """""""""""""
        'views/car_rental_contract_checklist_views.xml',
        'reports/report_fleet_rental.xml',
